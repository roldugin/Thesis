\input{preamble.tex}

\section{Loop representation: The Loop Language}

LiveFusion at the top level presents a library of high level array combinators, with each one representing a particualar array operation. Many of them conceptually represent a loop. However, we would like to be able to perform several such operations in one loop, whenever possible. Such fusible loops arise in the case where the result of one combinator is consumed as input by another. In the LiveFusion AST constructed at runtime this would correspond to a child producer node and its parent consumer node. How do we know whether two combinators can be fused? We discussed in Section (TODO ref) that just it is impractical for libraries with a large number of combinators to define rewrite rules for how each potential pair of combinators is fused together. We need to be more general than that. In principle, two combinators can be fused whenever you can write a loop by hand which would give the same result for the same input. We need a way to programmatically determine whether a given pair of combinators can be replace with a semantically equivalent loop.

The focus of this chapter is to establish the requirements for fusible combinators and define a loop sepresentation to which such fusible combinators can be mapped.



\subsection{Nature of fast loops}

+ inherently procedural
+ several combinators fuse to a single loop
+ must generate parts of the same loop



\subsection{Anatomy of a loop}

Despite the purely functional, combinatorial interface to the library, we have established that looking at a loop in a purely procedural way is the approach we opted for in the middle layer. It is represented by the Loop language. The loops we generate can be viewed as similar to those in the mainsteam procedural languages such as C, however there are two important differences. One positions our Loop language a step above the simple C loops while the other one, sadly, makes it low

However, 

+ Init
+ Guard
+ Body
+ Bottom
+ Done
+ Proceed by showing an exaple, slowly populating the loop
+ Identify problem of identifying common variables
+ Identify the problem of naming conventions


\subsection{Communication by Convention}

We have discussed that our loop clauses are being populated by combinators that do not know how many other combinators are in the pipeline or what these combinators are. And yet, once all of the combinators have filled in their parts, we end up with just one loop in which those combinators operate on the shared state. We will now discuss the approach by which those combinators cooperate with each other inside a single loop and how the state produced by one combinator is passed on to the combinators in the subsequent parts of the pipeline.

Let's look a simple example of what shared state a pipleline of two combinators |map g \$ map f \$ xs| is.


\subsubsection{Intermediate values}

As usual we decompose each combinator into a set of loop clauses. We have done this for the |map| combinator in the previous section. However, the added complication is that there are two |map|s, both of which expect an input value in $elt_i$ and and produce an output value in $elt_o$ at each iteration. This results in variable name clashes. We could give them unique names $elt_{i_1}$, $elt_{o_1}$, $elt_{i_2}$ and $elt_{o_2}$ based on the number of the combinator in the pipeline. We also notice that the output $elt_{o_1}$ of `map f` is fed as input $elt_{i_2}$ to `map g`. A simple solution is to introduce an equation $elt_{i_2} = elt_{o_1}$ for each combinator. This is the first example of interaction between combinators through shared state.
 $elt_{i_2} = elt_{i_1}$ might not be terribly exciting to read about

In the above example, we have established that for combinators that consume one element in each iteration, such as |map|, |fold| or |filter|, that element would be stored in variable $elt_{o_n}$ where *n* is the the unique number of the previous combinator in the pipleline. The prefix $elt_o$ is its generic form and designates the intermediate output value in an iteration. This is the first *convention* that we use in our *Loop* language to tie together the code generated by different combinators.

The two combinators |map g . map f| give us code similar to the following:

\begin{lstlisting}[mathescape]
body:
  $elt_{i_1}$ = $elt_{o_0}$          -- input  of `map f`
  $elt_{o_1}$ = f $elt_{i_1}$  -- output of `map f`
  $elt_{i_2}$ = $elt_{o_2}$          -- input  of `map g`
  $elt_{o_2}$ = g $elt_{i_1}$  -- output of `map g`
\end{lstlisting}

\subsubsection{Loop counters}

Another important *convention* that the Loop language uses in every loop it generates are the loop counter variables.
%% As we will see later the naming convention is not only used to tie together the code together but also gives rise to an optimisation and provides a solution to duplicated loop counters identified in Section (TODO ref).

The variables holding the *elements* of intermediate arrays we saw in the previous section are used in each cycle of the loop but do not represent the state that is carried over to the next iteration. The *loop counters* on the other hand are *mutable* variables that are destructively updated on each iteration and for part of the loop's state.

The most obvious place to introduce the counter variable is the |Manifest| combinator which lifts a physical array into the *LiveFusion* EDSL. It is required to produce an element in each iteration of the loop by indexing the physical array that it wraps. Therefore, the index is not simply the loop's overall state, but the state of the |Manifest| combinator.

To introduce this loop counter state we need to do the following:

In the |init|ialisation clause of the loop:
+ declare the counter variable
+ assign it the initial value of 0
+ declare length variable
+ assign it the length of the array

In the |guard|:
+ check if we have reached the end of the array
+ exit the the loop if we have

In the |bottom| clause of loop which deals with updating the state:
+ increment the variable using destructive update

Following the above steps introduces the loop counter into the loop. The remaining implementation of |Manifest| combinator resides in the main |body| of the loop:
+ declare an intermediate value $elt_o$ and read the physical array at the appropriate index into it

The complete loop definition resulting from lifting a physical array into LiveFusion EDSL using |Manifest| combinator is shown in Figure (TODO ref).

\begin{lstlisting}[mathescape]
init:
  $len_0$ = length $xs$
  $i_0$   = 0

guard:
  $pred_0$ = $i_0$ < $len_0$
  guard $pred_0$ done        -- goto done block if the predicate is false

body:
  $elt_{o_0}$ = read $xs$ $i_0$

bottom:
  $i_0$ = $i_0$ + 1

done:

\end{lstlisting}


\subsubsection{Merging Loops}

Coming back to our example of |map g \$ map f \$ xs| we now have both the code lifting |xs| into the loop computation as well as the code for the |map|s. Since theses are all part of the same loop, we can merge the statements from the same loop clauses into one loop. In this case the |map| combinators really only had statements in the |body| so this is the one clause which actually demonstates the loop merging:

\begin{lstlisting}[mathescape]
init:
  -- Manifest xs
  $len_0$ = length $xs$
  $i_0$   = 0

guard:
  -- Manifest xs
  $pred_0$ = $i_0$ < $len_0$
  guard $pred_0$ done        -- goto done block if the predicate is false

body:
  -- Manifest xs
  $elt_{o_0}$ = read $xs$ $i_0$
  -- Map f
  $elt_{i_1}$ = $elt_{o_0}$          -- input  of `map f`
  $elt_{o_1}$ = f $elt_{i_1}$  -- output of `map f`
  -- Map g
  $elt_{i_2}$ = $elt_{o_2}$          -- input  of `map g`
  $elt_{o_2}$ = g $elt_{i_1}$  -- output of `map g`

bottom:
  -- Manifest xs
  $i_0$ = $i_0$ + 1

done:

\end{lstlisting}


Technically, the loop for the manifest array is produced first. Then it is merged with the loop produced for `map f`. Then the resulting loop is merged with the loop produced for `map g`. We initially omitted the merging process for `map g . map f` expression to avoid introducing to many concepts at a time.


\subsubsection{Writing out the result}


\subsubsection{Loop Counters and Filters}

Suppose that we introduce



\subsubsection{Accumulators}



\subsubsection{Block names}



+ Many of the combinators use a similar set of variables, e.g. both Map and Scan produce a value at each iteration which they assign to an intermediate variable in the body of the loop, say elt
+ Thus if there are two maps one after the other, we need to distinguish between the two
+ We give earch such variable a unique identifier which coincides with the identifier of the combinator in the graph (see section), e.g. $elt_3$ is always an intermediate element produced by combinator 3 in each iteration (provided the combinator is a producer)
+ Other examples include $len_3$, $len_1$, $i_1$, $o_5$, $acc_4$
+ Not only this removes any potential name clashes (since ids are unique), but also allows us to refer to any variable in the loop just knowing what function it's performing as well as the combinator id.
+ When is it useful? Can we have a DS passing those variables without stupid conventions?
+ The problem is that the names are generated by convention, so in case of any error, the program would either fail to compile at runtime or produce incorrect results
+ The easiest way 
+ Like global variables
+ Spooky action at a distance
+ Untracked interaction between different parts of loop
+ In many cases a flaw of software design, often discouraged and even semantically prohibited in functional languages like haskell and ml.



\subsection{Procedural code: Imperator Language}

+ Loop still carries the common structure of having a guard, body, etc..
+ How do we generalise it to a procedural language
+ Identify relaxed constructs
+ Introduce simple liveness analysis

\end{document}
