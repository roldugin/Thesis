%% We use `subfiles' package
\documentclass[preamble.tex]{subfiles}
\begin{document}

\clearpage

\chapter{Conclusion}

The problem of array fusion is not in its infancy. Yet there is not a definitive widely accepted approach to it. Every approach has to be tailored to the surrounding context and align well with the programming model offered by the framework. The work described in the present dissertation has been carried out in the context of nested data parallelism (Chapter~\ref{ch:NDP}) in purely functional languages. It was argued that \*equational* approaches to fusion (Appendix~\ref{sec:Equational-Fusion-Systems}) fall short in attempting to fuse the complex combinator graphs (Section~\ref{sec:multiple-consumers}) using only local program transformations (rewrite rules).

Chapter~\ref{ch:frontend} introduced an EDSL based approach to fusion using the language called \LiveFusion. Following this approach the collective array operations are not performed immediately but are recorded in an AST. The chapter also covered the sharing recovery of AST terms\todo{ref} as well as a way of embedding inlineable scalar functions (Section~\ref{sec:Scalar-language}).

Chapter~\ref{ch:Loops} presented a common loop structure to which fusible combinators can be mapped using an assembly-like \Loop language. It showed the translation of a large number of combinators to the \Loop which included segmented combinators (Section~\ref{sec:Loops-segmented-combinators}) that are fundamental to fusing vectorised code.

Chapter~\ref{ch:Code-Generation} offered the requirements to the backend code generators such as fast mutable arrays and mutable variables. As an example it used a backend that generated monadic \Haskell code through the use of \name{Template Haskell}. The chapter also described \name{Liveness Analysis} used to analyse data flow in a control flow graph of \Loop's basic blocks (Section~\ref{sec:Liveness-analysis}). The analysis ensured that the generated code is well-scoped and all variables are assigned once (generating fresh names on destructive update).

Chapter~\ref{ch:results} applied the \LiveFusion framework to \QuickHull problem. The example was chosen since it was illustrative of \DPH vectoriser's inner workings and used a wide range of combinators offered by \LiveFusion. It was shown that \LiveFusion's ability to fuse more complex combinator graphs can yield speedups of up to 5 times and 3.2 on average as complared to \StreamFusion even with high runtime compilation costs.


\IfNotCompilingAll{\bibliography{bib}}

\end{document}
