% Simply \input{index} in preamble

% Be sure to put \idx after punctuation,\idx{foo} not before\idx{bar}
% to avoid extra spaces. For some reason \xspace does not help.
\newcommand{\idx}[1]{\index{#1} }


\makeindex
\providecommand{\indexe}[1]{\idx{#1}\emph{#1}}
\providecommand{\indext}[1]{\idx{#1}#1}


% Languages
\providecommand{\ilanguage}[1][]{\idx{language!#1}}
\providecommand{\iedsl}[1][]{\idx{language!embedded!#1}}
\providecommand{\idsl}[1][]{\idx{language!domain-specific!#1}}


% LiveFusion AST, ASG, frontend, etc..
\providecommand{\iast}[1][]{\idx{AST (abstract syntax tree)!#1}}
\providecommand{\iasg}[1][]{\idx{ASG (abstract semantic graph)!#1}}
\providecommand{\icollop}[1][]{\idx{collective operation!#1}}
\providecommand{\isegd}[1][]{\idx{segment descriptor!#1}}
\providecommand{\icomb}[1][]{\idx{combinator!#1}}
\providecommand{\isegcomb}[1][]{\idx{combinator!segmented!#1}}
\providecommand{\iflatcomb}[1][]{\idx{combinator!flat!#1}}
\providecommand{\igencomb}[1][]{\idx{combinator!generator!#1}}
\providecommand{\ipurecon}[1][]{\idx{combinator!pure consumer!#1}}

% Also:
\idx{pure producers|see {combinator: generator}}
\idx{generator|see {combinator: generator}}
\idx{pure consumer|see {combinator: pure consumer}}

% Scalar language
\providecommand{\iscalarlang}[1][]{\idx{language!scalar!#1}}
\providecommand{\ihoas}[1][]{\idx{HOAS (higher-order abstract syntax)!#1}}
\providecommand{\idebruijn}[1][]{\idx{De Bruijn!#1}}


% Fusion talk
\providecommand{\ifusion}[1][]{\idx{fusion!#1}}
\providecommand{\ieqfusion}[1][]{\idx{equational fusion!#1}}
\providecommand{\iintermediate}[1][]{\idx{intermediate value!#1}}
\providecommand{\irate}[1][]{\idx{rate!#1}}
\providecommand{\istreamfusion}[1][]{\idx{fusion!Stream Fusion!#1}}
\providecommand{\ifaf}[1][]{\idx{fusion!Functional Array Fusion!#1}}
\providecommand{\ishortcut}[1][]{\idx{fusion!foldr/build!#1}}
\providecommand{\ipipe}[1][]{\idx{pipeline!#1}}
% Also
\idx{deforestation|see {fusion}}


% Loop language
\providecommand{\iloop}[1][]{\idx{Loop EDSL!#1}}
\providecommand{\iblock}[1][]{\idx{basic block!#1}}


% Code generation
\providecommand{\ith}[1][]{\idx{Template Haskell!#1}}
\providecommand{\ihost}[1][]{\idx{host program!#1}}
\providecommand{\iplugin}[1][]{\idx{plugin!#1}}


% DPH
\providecommand{\idph}[1][]{\idx{DPH (Data Parallel Haskell)!#1}}
\providecommand{\ivect}[1][]{\idx{vectoriser, vectorisation!#1}}
\providecommand{\indp}[1][]{\idx{data parallelism!nested!#1}}

% GHC and optimisations
\providecommand{\ighc}[1][]{\idx{GHC (Glasgow Haskell Compiler)!#1}}
\providecommand{\iinl}[1][]{\idx{inlining!#1}}
\providecommand{\irw}[1][]{\idx{rewriting, term rewriting!#1}}
\providecommand{\irwrules}[1][]{\idx{rewrite rule!#1}}
\providecommand{\iboxing}[1][]{\idx{boxing!#1}}
% Also:
\idx{unboxed values|see {boxing}}
\idx{boxed values|see {boxing}}
\idx{unboxing|see {boxing}}


% Misc
\providecommand{\ipe}[1][]{\idx{processing element!#1}}
\providecommand{\iarray}[1][]{\idx{array!#1}}
\providecommand{\imanifest}[1][]{\idx{array!manifest!#1}}
\providecommand{\isegarray}[1][]{\idx{array!segmented!#1}}
\providecommand{\iflatarray}[1][]{\idx{array!flat!#1}}
\providecommand{\iqh}[1][]{\idx{QuickHull!flat!#1}}
% Also:
\idx{convex hull|see QuickHull}


\idx{DSL|see {language!domain-specific}}
\idx{EDSL|see {language!embedded}}

