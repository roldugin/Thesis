# Loop representation: The Loop Language #



## Nature of fast loops ##

- inherently procedural
- several combinators fuse to a single loop
- must generate parts of the same loop



## Parts of a loop ##

- Init
- Guard
- Body
- Bottom
- Done
- Proceed by showing an exaple, slowly populating the loop
- Identify problem of identifying common variables
- Identify the problem of naming conventions


## Communication by convention ##

- Many of the combinators use a similar set of variables, e.g. both Map and Scan produce a value at each iteration which they assign to an intermediate variable in the body of the loop, say elt
- Thus if there are two maps one after the other, we need to distinguish between the two
- We give earch such variable a unique identifier which coincides with the identifier of the combinator in the graph (see section), e.g. `elt_3` is always an intermediate element produced by combinator 3 in each iteration (provided the combinator is a producer)
- Other examples include `len_1`, `i_1`, `o_5`, `acc_4`
- Not only this removes any potential name clashes (since ids are unique), but also allows us to refer to any variable in the loop just knowing what function it's performing as well as the combinator id.
- When is it useful? Can we have a DS passing those variables without stupid conventions?
- The problem is that the names are generated by convention, so in case of any error, the program would either fail to compile at runtime or produce incorrect results
- The easiest way 
- Like global variables
- Spooky action at a distance
- Untracked interaction between different parts of loop
- In many cases a flaw of software design, often discouraged and even semantically prohibited in functional languages like haskell and ml.



## Procedural code: Imperator Language ##

- Loop still carries the common structure of having a guard, body, etc..
- How do we generalise it to a procedural language
- Identify relaxed constructs
- Introduce simple liveness analysis



## Procedural code: Imperator Language ##
- Loop still carries the common structure of having a guard, body, etc..
- How do we generalise it to a procedural language
- Identify relaxed constructs
- Introduce simple liveness analysis
